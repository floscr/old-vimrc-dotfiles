#!/bin/bash

local dotfiles_dir="/Users/$(whoami)/.homesick/repos/dotfiles"
local functions_path="$dotfiles_dir/home/.dotfiles/functions"

. "$functions_path/function-navigation_and_files.zsh"
. "$functions_path/function-compression.zsh"
. "$functions_path/function-video_and_audio.zsh"
. "$functions_path/function-git.zsh"
. "$functions_path/function-images.zsh"
. "$functions_path/function-server.zsh"
. "$functions_path/function-osx.zsh"
. "$functions_path/function-coding.zsh"

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

# Check if a command exists
# Example
# if _command_exists nvim; then echo 'Nvim exists!'; fi
# http://stackoverflow.com/a/3931779
_command_exists() {
  type "$1" &> /dev/null ;
}

# Echo red error message
# _error_msg "Error message"
_error_msg() {
  RED='\033[0;31m'
  NC='\033[0m' # No Color
  echo "${RED}$@${NC}"
}

# Lazyloading programs so they wont slow down shell startup
# https://gist.github.com/QinMing/364774610afc0e06cc223b467abe83c0
_lazy_load() {
  # Act as a stub to another shell function/command. When first run, it will load the actual function/command then execute it.
  # E.g. This made my zsh load 0.8 seconds faster by loading `nvm` when "nvm", "npm" or "node" is used for the first time
  # $1: space separated list of alias to release after the first load
  # $2: file to source
  # $3: name of the command to run after it's loaded
  # $4+: argv to be passed to $3
  GREY='\033[01;30m'
  NC='\033[0m'
  echo "${GREY}Lazy loading $1 ...${NC}"

  # $1.split(' ') using the s flag. In bash, this can be simply ($1) #http://unix.stackexchange.com/questions/28854/list-elements-with-spaces-in-zsh
  # Single line won't work: local names=("${(@s: :)${1}}"). Due to http://stackoverflow.com/questions/14917501/local-arrays-in-zsh   (zsh 5.0.8 (x86_64-apple-darwin15.0))
  local -a names
  if [[ -n "$ZSH_VERSION" ]]; then
    names=("${(@s: :)${1}}")
  else
    names=($1)
  fi
  unalias "${names[@]}"
  . $2
  shift 2
  $*
}

_group_lazy_load() {
  local script
  script=$1
  shift 1
  for cmd in "$@"; do
    alias $cmd="_lazy_load \"$*\" $script $cmd"
  done
}

# Opens a man page as a pdf in preview
function pman() {
  man -t $1 | open -f -a /Applications/Preview.app
 }

# Opens man page in Sublime
function sman() {
 man "${1}" | col -b | open -f -a /Applications/Sublime\ Text.app/Contents/MacOS/Sublime\ Text
}


# List global installed packages
# npm ls -g can be super slow so this is a workaround
# Requires node to be installed via nvm
#
# The Official way, which is way to slow:
# npm ls --depth=0 -g "$@" 2>/dev/null
function npmls() {
  # Workaround for a fast global package listing
  ls -1 ~/.nvm/versions/node/$(node -v)/lib/node_modules
}

# [numhash]:
# Create a numeric hash with x digits
function numhash() {

  # If there is no parameter passed create a 32 character hash
  if [[ -z $1 ]]; then
    local digit=32
  else
    local digit="$1"
  fi

  # Create a numeric x character long hash
  cat /dev/urandom | env LC_CTYPE=C tr -dc '0-9' | fold -w $digit | head -n 1
}

# [xhash]:
# Create a numeric hash with x digits
function xhash() {

  # If there is no parameter passed create a 32 character hash
  if [[ -z $1 ]]; then
    local digit=32
  else
    local digit="$1"
  fi

  # Create a numeric x character long hash
  cat /dev/urandom | env LC_CTYPE=C tr -dc 'a-zA-Z0-9' | fold -w $digit | head -n 1
}

# Fix the asepsis control after updating
function ds_store_update_cleaner () {
  asepsisctl uninstall_wrapper
  asepsisctl install_wrapper
}
