#+TITLE: Emacs Doom configuration
#+AUTHOR: Florian Schrödl (floscr)
#+PROPERTY: header-args :tangle yes
#+STARTUP: org-startup-folded: showall
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Configuration
** About

This is my emacs config for [[https://github.com/hlissner/doom-emacs][doom-emacs]].

#+BEGIN_SRC elisp
(setq user-full-name "Florian Schrödl")
#+END_SRC

** Essentials
*** Directories
#+BEGIN_SRC elisp
(defcustom downloads-dir "~/Downloads/"
  "Directory containing my downloads."
  :type 'string)

(defcustom screenshot-dir "~/Pictures/Screenshots"
  "Directory containing my screenshots."
  :type 'string)
#+END_SRC
** Utilities
*** Macros
**** Aliases
#+BEGIN_SRC elisp
(defalias 'λ 'lambda)
#+END_SRC
**** Template Literals
:PROPERTIES:
:SOURCE:   https://gist.github.com/cbowdon/012d623920bd28453bf8
:END:

#+BEGIN_SRC elisp :tangle no
(template "2 = <<(+ 1 1)>>")
#+END_SRC

#+RESULTS:
: 2 = 2

#+BEGIN_SRC elisp
(defmacro template (text)
  "Template literals"
  (let ((pattern "<<\\(.*?\\)>>"))
    ;; The regexp matches anything between delimiters, non-greedily
    (with-temp-buffer
      (save-excursion (insert text))
      (let ((matches '()))
        (while (re-search-forward pattern nil t)
          (push (match-string 1) matches)
          (replace-match "%s" t t))
        `(format ,(buffer-string) ,@(reverse (mapcar 'read matches)))))))
#+END_SRC
*** General Helpers
**** Noop
#+BEGIN_SRC elisp
(defun noop (args) nil)
#+END_SRC
**** Run JXA scripts
#+BEGIN_SRC elisp
(defun do-jxa-script (cmd)
  "Run a osx javascript automation script via bash"
  (shell-command-to-string
   (concat "osascript -l 'JavaScript' -e '" cmd "'")))
#+END_SRC
**** Eval and Replace sexp
:PROPERTIES:
:SOURCE:   https://emacsredux.com/blog/2013/06/21/eval-and-replace/
:END:

#+BEGIN_SRC elisp
(defun eval-and-replace-sexp ()
  "Replace the preceding sexp with its value."
  (interactive)
  (right-char) ;; Fix for normal mode
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
#+END_SRC
**** Kill and Message
#+BEGIN_SRC elisp
(defun copy-message (x)
  "Executes kill-new but with a message log side effect"
  (kill-new x)
  (message "Copied to clipboard: %s" x))
#+END_SRC
*** Math on Numbers
#+BEGIN_SRC elisp
(defun math-on-number (f &optional num)
  "Read user input and apply with function f to the number at point"
  (let* ((x (thing-at-point 'number))
         (arithmetic-symbol (pcase f
                              ('+ "+")
                              ('- "-")
                              ('/ "/")
                              ('* "*")
                              (_ (error "Unknown function %s" f))))
         (readline (concat (number-to-string x) " " arithmetic-symbol " "))
         (y (or num (read-number readline)))
         (result (funcall f x y))
         (bounds (bounds-of-thing-at-point 'evil-WORD)))
    (delete-region (car bounds) (cdr bounds))
    (insert (format "%.02f" result))))

(defun +math|add-to-number ()
  (interactive)
  (math-on-number '+))

(defun +math|subtract-from-number ()
  (interactive)
  (math-on-number '-))

(defun +math|subtract-maran-vegan ()
  (interactive)
  (math-on-number '- 8.60))

(defun +math|divide-by-number ()
  (interactive)
  (math-on-number '/))

(defun +math|multiply-by-number ()
  (interactive)
  (math-on-number '*))
#+END_SRC
*** Toggle Window Dedicated
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows][buffers - How can I prevent a command from using specific windows? - Emacs Stack Exchange]]
:END:

To lock a window you set the dedicadet flag on the window.

#+BEGIN_SRC elisp
(defun toggle-window-dedicated ()
  "Control whether or not Emacs is allowed to display another
buffer in current window."
  (interactive)
  (message
   (if (let (window (get-buffer-window (current-buffer)))
         (set-window-dedicated-p window (not (window-dedicated-p window))))
       "%s: Window locked!"
     "%s: Window unlocked!")
   (current-buffer)))
#+END_SRC
*** Workspace
**** Switch to last visited workspace
#+BEGIN_SRC elisp
(defun +workspace/switch-to-last-visited ()
  "Switch to the last visited workspace."
  (interactive)
  (+workspace/switch-to +workspace--last))
#+END_SRC
**** Find file for workspace
Most of the time you create workspaces from a project.
But when the CWD has changed in that workspace, you would have to relocate to
the projects cwd to find a file.

#+BEGIN_SRC elisp
(defun my-find-workspace-project-root (&optional arg)
  "Gets the root dir for the current workspace"
  (--find (s-match (concat (+workspace-current-name) "/$") it) projectile-known-projects))

(defun +workspace|find-workspace-project-file ()
"Projectile find file for the project named after the current workspace."
  (interactive)
  (cl-letf (((symbol-function 'projectile-project-root) #'my-find-workspace-project-root))
      (projectile-find-file)))
#+END_SRC

**** New named workspace
#+BEGIN_SRC elisp
(defun +workspace/new-named ()
  "Create a new named workspace."
  (interactive)
  (let ((name (read-string "New workspace name: ")))
    (if name (+workspace/new name))))
#+END_SRC
*** File Utilities
**** Get the last file in directory
:PROPERTIES:
:SOURCE:   https://stackoverflow.com/a/30886283
:END:

- Used in [[*Screenshot][Screenshot]]

#+BEGIN_SRC elisp
(defun latest-file (path)
  (let ((e (f-entries path)))
    (car (sort e (lambda (a b)
                   (not (time-less-p (file-timestamp a)
                                     (file-timestamp b))))))))

(defun file-timestamp (f) (let ((attrs (file-attributes f))) (nth 5 attrs)))
#+END_SRC
**** Reveal in Finder

The regular ~+macos/reveal-in-finder~ in doom only opens the folder.
This fix opens the folder and selects the file.

#+BEGIN_SRC elisp
(defun +macos/reveal-in-finder ()
  "Reveal the current file in finder and select it"
  (interactive)
  (do-applescript (concat
                   "tell application \"Finder\"\n"
                   "    activate\n"
                   "    reveal POSIX file \"" (buffer-file-name) "\"\n"
                   "end tell")))
#+END_SRC
**** Show Next/Previous file in file listing
#+BEGIN_SRC elisp
(defun my-next-ls-file (&optional direction)
  "Gives you the next file of a listing in the current dictionary"
  (interactive)
  (let* ((direction (or direction 1))
         (files (-drop 2 (directory-files (file-name-directory (buffer-file-name)) nil nil nil)))
         (current-index (-elem-index (file-name-nondirectory buffer-file-name) files))
         (file-length (- (length files) 1))
         (next-index (+ current-index direction)))
    (--> (cond
          ((equal (> file-length next-index) 0))
          ((equal (< 0 next-index) file-length))
          (t next-index))
        (nth it files))))
#+END_SRC
**** Open private config
#+BEGIN_SRC elisp
(defun doom/find-private-org-config ()
  "Opens config.org"
  (interactive)
  (let ((filename (concat doom-private-dir "config.org")))
    (or
     (switch-to-buffer (find-buffer-visiting (concat doom-private-dir "config.org")))
     (find-buffer-visiting filename))))
#+END_SRC

*** Hydra Expand Region
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/also27/second_trial_for_a_weekly_tipstricksetc_thread/efi7pbj/
:END:

Expand region using a hydra.
Double press ~v~ to enable.

#+BEGIN_SRC elisp
(defhydra hydra-expand-region ()
   "region: "
   ("f" er/mark-defun "defun")
   ("v" er/expand-region "expand")
   ("V" er/contract-region "contract"))

(evil-define-key 'visual 'global (kbd "v") #'hydra-expand-region/body)
#+END_SRC
** UI
*** System specific window modifications

Resize the window font size etc according to the system.
This will be disabled in terminal mode.

#+BEGIN_SRC elisp
(when (display-graphic-p)
#+END_SRC

#+BEGIN_SRC elisp
(defcustom my-default-frame-size nil
  "A cons cell of screen dimensions (width . height)"
  :type 'cons)

(defcustom osx-screen-reserved-y-space 48
  "How much of the screen is available when subtracting the
1. app title bar
2. menu bar"
  :type 'integer)

(defcustom osx-screen-reserved-x-space 12
  "How much of the screen is available when subtracting the
1. Window Border"
  :type 'integer)

(defun my-set-initial-frame-size (size)
  "Set the initial frame"
  (let* ((width (car size))
         (height (cdr size))
         (left (- (x-display-pixel-width) width)))
    (setq initial-frame-alist
          (append (list `(left . ,left)
                        `(width . ,width)
                        '(fullscreen . fullheight))
                  initial-frame-alist)))
  (setq my-default-frame-size size))

(defun my-frame-resize-width (width)
  "Set the frame WIDTH. Maximize the frame vertically (minus the osx reserver space)"
  (set-frame-width (selected-frame) width nil t)
  (set-frame-height (selected-frame) (- (x-display-pixel-height) osx-screen-reserved-y-space) nil t)
  (set-frame-position (selected-frame) (- (x-display-pixel-width) width osx-screen-reserved-x-space) 0))

(defun my-frame-resize-work-external ()
  "External Monitor at work"
  (interactive)
  (my-frame-resize-width 1410))

(cond
 ((string= system-name "Florians-MBP.localdomain")
  (my-frame-resize-work-external)
  ;; (my-set-initial-frame-size (cons 2 1060))
  (setq-default line-spacing 0.3))
 ((string= system-name "Florians-iMac.local")
  (setq-default line-spacing 0.3))
 ((string= system-name "Florians-MacBook-Air.local")
  (setq-default line-spacing 0.4)
  (setq initial-frame-alist
        (append (list '(left . 272)
                      '(width . 165)
                      '(fullscreen . fullheight))
                initial-frame-alist)))
 (t (setq-default line-spacing 0.15)))
#+END_SRC


#+BEGIN_SRC elisp
)
#+END_SRC

*** Theme Toggle

Allows me to toggle quickly between two themes.

#+BEGIN_SRC elisp
(defconst light-theme 'doom-one)
(defconst dark-theme  'doom-one-light)

(defun +doom|toggle-theme ()
  "Toggle between light and dark themes."
  (interactive)
  (cond ((eq doom-theme dark-theme)
         (message "Toggling to light-theme: %s" light-theme)
         (setq doom-theme light-theme)
         (doom/reload-theme))
        ((eq doom-theme light-theme)
         (message "Toggling to dark-theme: %s" dark-theme)
         (setq doom-theme dark-theme)
         (doom/reload-theme))
        (t (message "Toggling theme is not possible. Theme is not currently light-theme (%s) or dark-theme (%s)." light-theme dark-theme))))
#+END_SRC
*** Scrolloff

Start scrolling X lines before the end of a screen.
Disable for terminal buffers, since there cane be issues completion/interactive
shell scripts.

#+BEGIN_SRC elisp
(setq
 scroll-conservatively 10
 scroll-margin 10)

(add-hook 'term-mode-hook (λ! (setq-local scroll-margin 0)))
(add-hook 'ivy-mode-hook (λ! (setq-local scroll-margin 0)))
#+END_SRC
*** Line Spacing

Change and reset line-spacing for all buffers.

#+BEGIN_SRC elisp
(defvar default-line-spacing 0.2)

(defun set-line-spacing (&optional spacing)
  "Set the line spacing
When no line spacing is given is the default-line-spacing"
  (if line-spacing
      (setq-default line-spacing (+ (or spacing default-line-spacing) line-spacing))
    (setq-default line-spacing (+ 0 default-line-spacing))))

(defun +ui|reset-line-spacing ()
  (interactive)
  (setq-default line-spacing nil))

(defun +ui|increase-line-spacing ()
  (interactive)
  (set-line-spacing))

(defun +ui|decrease-line-spacing ()
  (interactive)
  (set-line-spacing (- default-line-spacing)))

(evil-define-key 'normal 'global (kbd "]z") #'+line-spacing/step/body)

;;;###autoload (autoload '+common-lisp/macrostep/body "lang/common-lisp/autoload/hydras" nil nil)
(defhydra +line-spacing/step (:exit nil :hint nil :foreign-keys run)
  "
Macro Expansion
^^Definitions                           ^^Compiler Notes             ^^Stickers
^^^^^^─────────────────────────────────────────────────────────────────────────────────────
[_z_] Expand
[_Z_] Collapse
"
  ("z" +ui|increase-line-spacing)
  ("Z" +ui|decrease-line-spacing)
  ("q" noop :exit t))
#+END_SRC
*** Popups
#+BEGIN_SRC elisp
(after! org
  (set-popup-rule! "^\\*Org Agenda" :side 'right :size 0.55 :select t :modeline t :ttl nil)
  (set-popup-rule! "^\\*Org Src" :side 'right :size 0.55 :select t :modeline t :ttl nil))

(set-popup-rule! "^\\*helm" :vslot -100 :size 0.32 :ttl nil)
(set-popup-rule! "^\\*doom:scratch" :vslot -100 :size 0.6 :ttl nil)
#+END_SRC
*** Fill Column
#+BEGIN_SRC elisp
(setq-default fill-column 110)
(setq visual-fill-column-width fill-column)
#+END_SRC
** Work
#+BEGIN_SRC elisp
(map!
 :n "[1" #'+MM|other-file
 :n "]1" #'+MM|other-file)

(defvar +Meisterlabs-Web-mode nil)

(def-project-mode! +Meisterlabs-Web-mode
  :when (bound-and-true-p +Meisterlabs-Web-mode-enabled))

(setq projectile-project-search-path '("~/Code/Meisterlabs"))

(after! yasnippet
  :config
  (setq yas-snippet-dirs (append yas-snippet-dirs '("~/Code/Meisterlabs/Snippets"))))

(defun +MM|other-file ()
  "Toggle between component or controller"
  (interactive)
  (setq filename (file-name-nondirectory buffer-file-name))
  (setq path (file-name-directory buffer-file-name))
  (setq target (if (string= filename "component.js") "controller.js" "component.js"))
  (find-file (concat path target)))

(fset '+MM|turn-style-object-into-function
      (lambda (&optional arg)
        "Turns an object into a Style function, needs to be focused on the starting {"
        (interactive "p")
        (kmacro-exec-ring-item (quote ([?y ?s ?a ?B ?b ?i ?S ?t ?y ?l ?e escape ?l ?a ?f ?u ?n ?c ?t ?i ?o ?n ?  S-backspace ?  ?\( ?o ?p ?t ?i ?o ?n ?s ?, ?  ?R ?u ?l ?e ?s escape ?l ?l ?y ?s ?a ?B ?B ?i ?  escape ?l ?a return ?r ?e ?t ?u ?r ?n ?  escape ?l ?j ?> ?i ?\{ ?k ?$ ?% ?a return escape ?k ?a ?\; escape ?= ?= ?j ?b ?l ?%] 0 "%d")) arg)))

(defun +MM|convert-to-new-redux-style ()
  "Converts the current buffer to the new redux style"
  (interactive)
  (shell-command (template "jscodeshift --dry --print --silent --transform ~/Code/Meisterlabs/jscodeshift/redux/v5.8.0/actions-controllers.js <<(buffer-file-name)>>") (current-buffer)))

(fset 'js2r-mm-extract-props
      (lambda (&optional arg)
        "Extract function props to statement"
        (interactive "p")
        (kmacro-exec-ring-item (quote ([?c ?i ?b ?p ?r ?o ?p ?s escape ?o escape ?p ?= ?= ?^ ?i ?c ?o ?n ?s ?t ?  escape ?a escape escape ?A ?  ?= ?  ?p ?r ?o ?p ?s escape ?A ?\; escape ?b ?b ?b ?b ?  ?m ?r ?e ?e ?A ?\C-? ?, escape ?j ?b])) arg)))

(defun dated-string (name)
  (format "%s-name" (format-time-string "%m-%d")))

(defun js2r-mm-taplog ()
  "Insert tap log"
  (interactive)
  (newline-and-indent)
  (yas-lookup-snippet "Tap Console Log" 'js2-mode))


;; (defun +MM|toggle-relative()
;;   (interactive)
;;   )

;; (s-match-strings-all "\\.\\.\\/" "import { foo } from './../../foo")
;; (s-split-up-to "src/" "~/Code/Meisterlabs/mindmeister-web/src/containers/PrivateMaps/ListRow/Map/NonViewable/style.js")

;; (defun +MM|dated-branch ()
;;   "Push the current branch as a dated branch"
;;   (interactive)
;;   (let ((dated-branch (magit-get-current-branch)))

;;     )
;;   (magit-get-current-branch)
;;   )
#+END_SRC
*** Create action

Create an action from a controller and import directly

#+BEGIN_SRC elisp
(defun +MM|create-action ()
  "Create an action file from a controller file"
  (interactive)
  (let* ((action-name (read-string "Action Name: "))
         (root-dir (file-name-directory (buffer-file-name)))
         (actions-dir (concat root-dir "actions/"))
         (actions-index-file (concat actions-dir "index.js"))
         (action-file (concat actions-dir (concat action-name ".js"))))
    (unless (file-directory-p actions-dir) (mkdir actions-dir))
    (copy-file
     (concat (projectile-project-root) "snippets/Core/Action.js")
     action-file)
    (with-temp-file actions-index-file
      (+js|generate-index actions-dir))
    (find-file action-file)))
#+END_SRC

*** Search MapEditor Only

#+BEGIN_SRC elisp
(defun +MM|canvas-files ()
  "Project files but only for canvas"
  (interactive)
  (ivy-read "Find File: "
            (--filter (s-contains? "MapEditor" it) (projectile-current-project-files))
            :action #'projectile-find-file))
#+END_SRC

** Packages & Modules
*** Company

Sort company by occurance [[https://github.com/company-mode/company-mode/issues/52][{Proposal} Improve company-dabbrev candidate ordering · Issue #52 · company-mode/company-mode]]

#+BEGIN_SRC elisp
(setq company-transformers '(company-sort-by-occurrence)
      company-idle-delay 0.5)
#+END_SRC

Select last item of company

#+BEGIN_SRC elisp :tangle no
(defun company-select-last ()
  (interactive)
  (company-select-next (- company-candidates-length 1)))
#+END_SRC

**** Bindings
#+BEGIN_SRC elisp
(map!
 (:prefix "C-x"
   :i "C-l" #'+company/whole-lines-all-buffers
   :i "C-." #'+company/whole-lines))
#+END_SRC

**** Company complete whole lines for all matching buffers

Complete a whole line with all lines from buffers matching the current major-mode.

#+BEGIN_SRC elisp
(defun floscr:buffer-list-with-modes (modes)
  "Get all buffers that match MODES"
  (--filter
   (with-current-buffer it (-contains? (doom-enlist modes) major-mode))
   (buffer-list)))

(defun floscr:buffer-list-with-major-mode ()
  "Get all buffers matching the current major-mode
Has built in aliases"
  (let ((javascript-modes (list 'rjsx-mode 'js2-mode)))
    (pcase major-mode
      ('rjsx-mode
       (floscr:buffer-list-with-modes javascript-modes))
      ('js2-mode
       (floscr:buffer-list-with-modes javascript-modes))
      (_
       (floscr:buffer-list-with-modes major-mode)))))

(defun +company/whole-lines-all-buffers (command &optional arg &rest ignored)
  "`company-mode' completion backend that completes whole-lines, akin to vim's
C-x C-l."
  (interactive (list 'interactive))
  (require 'company)
  (pcase command
    (`interactive (company-begin-backend '+company/whole-lines-all-buffers))
    (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
    (`candidates
     (all-completions
      arg
      (funcall (-compose
                #'-uniq
                #'-flatten
                (lambda (xs)
                  (--map (with-current-buffer it
                           (split-string
                            (replace-regexp-in-string
                             "^[\t\s]+" ""
                             (buffer-substring-no-properties (point-min) (point-max)))
                            "\\(\r\n\\|[\n\r]\\)" t)) xs)))
               (floscr:buffer-list-with-major-mode))))))
#+END_SRC

*** Eldoc
#+BEGIN_SRC elisp
;; Always truncate ElDoc messages to one line. This prevents the echo
;; area from resizing itself unexpectedly when point is on a variable
;; with a multiline docstring.
(setq eldoc-echo-area-use-multiline-p nil)

;; Show ElDoc messages in the echo area immediately, instead of after
;; 1/2 a second.
(setq eldoc-idle-delay 0)

;; Disable eldoc mode
(global-eldoc-mode -1)
#+END_SRC
*** Git
**** Config
#+BEGIN_SRC elisp
(setq-default magit-save-repository-buffers 'dontask)

(after! magit
  :config
  (setq
   magithub-clone-default-directory "~/Code/Repositories"
   git-commit-summary-max-length 120))
#+END_SRC
**** Bindings
***** Magit Navigation Binding

My workflow for navigating diffs
Use ~z1~ to fold all diffs to their file headers and presss ~{~ or ~}~ to

1. Refold all sections
2. Go to the next section
3. Unfold everything in the current section

Then use ~]~ to navigate the sections

#+BEGIN_SRC elisp
(defun floscr:magit-jumpunfold-section (&optional forward)
  "Fold all section. Go to next section when FORWARD. Show all children"
  (interactive)
  (magit-section-show-level-1-all)
  (call-interactively (if forward #'magit-section-forward-sibling #'magit-section-backward-sibling))
  (call-interactively #'magit-section-show-children))

(map!
 (:after evil-magit
   :map (magit-diff-mode-map)
   :n "}" (λ! (floscr:magit-jumpunfold-section 't))
   :n "{" (λ! (floscr:magit-jumpunfold-section))))
#+END_SRC

***** Magit Window Navigation Binding Fixes

Fixes evil window navigation for magit

#+BEGIN_SRC elisp
(map!
 (:after evil-magit
   :map (magit-status-mode-map magit-revision-mode-map magit-diff-mode-map)
   :n "C-j" #'evil-window-down
   :n "C-k" #'evil-window-up
   :n "C-h" #'evil-window-left
   :n "C-l" #'evil-window-right))
#+END_SRC

***** Git Local Leader Bindings

#+BEGIN_SRC elisp
(map! :map global-git-commit-mode-map
      :n "Q" #'+dired|kill-dired-buffers)

(map!
 :leader
 (:desc "Magit" :prefix "g"
   :desc "Worktree Popup" :n  "%" #'magit-worktree
   :desc "Map-editor Changed Files"  :n  "T" (λ! (+git|ivy-changed-files "map-editor"))
   :desc "Changed Files"  :n  "F" #'+git|ivy-changed-files
   :desc "Fetch"          :n  "f" #'magit-fetch
   :desc "Push"           :n  "p" #'magit-push
   :desc "Undo"           :n  "u" #'+git|undo))
#+END_SRC

**** Revision show orignal file

Show the orginal file when visiting a revision buffer.
E.g.: When showing a diff from a commit, you may want to edit that file.

#+BEGIN_SRC elisp
(defun magit-revision-show-original-file ()
  "Show the orginal file from a revision buffer
If possible also go to the pointing line"
  (interactive)
  (when magit-buffer-file-name
    (let ((file-name magit-buffer-file-name)
          (line-number (line-number-at-pos)))
      (delete-other-windows)
      (find-file file-name)
      (goto-line line-number))))
#+END_SRC

**** Git Changed Files

Show a list of the changed files in the current branch.
For now only works on branches that were directly forked from master.

#+BEGIN_SRC elisp
(defun shell-command-to-list (cmd)
  "Split output from shell-command to list"
  (split-string (shell-command-to-string cmd) "\n" t))

(defun git-new-files ()
  (shell-command-to-list "git ls-files -om --exclude-standard"))

(defun git-modified-files (&optional branch)
  (shell-command-to-list
   (template "git --no-pager diff --no-renames --name-only --no-merges <<(magit-rev-parse \"HEAD\")>> <<branch>>;")))

(defun git-get-changed-files (b)
    (delete-dups (append (git-modified-files b) (git-new-files))))

(defun +git|ivy-changed-files (&optional branch)
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (ivy-read (template "Changed files for <<branch>>:")
              (git-get-changed-files (or branch "master"))
              :require-match t
              :history 'file-name-history
              :action counsel-projectile-find-file-action
              :caller '+git|ivy-changed-files)))
#+END_SRC
**** Browse git link

#+BEGIN_SRC elisp
(defun browse-git-link ()
  "Browse the git link at the current point"
  (interactive)
  (let ((git-link-open-in-browser t))
    (call-interactively 'git-link)))
#+END_SRC
**** Create New Git Worktree Workspace

Creates a new git workspace from a branch.
Automatically adds ~.projectfile~ and opens a new doom workspace.

#+BEGIN_SRC elisp
(defun magit-worktree-branch-project-worktree (branch start-point &optional force)
  "Create a new BRANCH and check it out in a new worktree at PATH in a new workspace."
  (interactive
   `(,@(butlast (magit-branch-read-args "Create and checkout branch"))
     ,current-prefix-arg))
  (let* ((worktree-path (f-join (projectile-project-root) ".worktrees"))
         (path (f-join (projectile-project-root) ".worktrees" branch)))
    (when (not (f-exists-p worktree-path))
      (mkdir worktree-path t))
    (magit-run-git "worktree" "add" (if force "-B" "-b")
                   branch (expand-file-name path) start-point)
    (f-touch (f-join path ".projectile"))
    (+workspace-new branch)
    (+workspace-switch branch)
    (magit-diff-visit-directory path)
    (projectile-add-known-project path)
    path))

(defun +MM|new-worktree ()
  "New worktree with the devpanel files and an npm install"
  (interactive)
  (let ((path (call-interactively 'magit-worktree-branch-project-worktree)))
    (npm-mode)
    (npm-mode-npm-install)))
#+END_SRC

**** Git undo
#+BEGIN_SRC elisp
(defun +git|undo ()
  "Soft reset current git repo to HEAD~1."
  (interactive)
  (magit-reset-soft "HEAD~1"))
#+END_SRC
**** TODO Insert message from commit history
#+BEGIN_SRC elisp :tangle no
(defun +git|commit-search-message-history ()
  "Search and insert commit message from history."
  (interactive)
  (insert (completing-read "History: "
                           ;; Remove unnecessary newlines from beginning and end.
                           (mapcar (lambda (text)
                                     (string-trim text))
                                   (ring-elements log-edit-comment-ring)))))
#+END_SRC
*** JSON
**** Autofix JSON

Uses [[https://www.npmjs.com/package/json-fix][json-fix]] to autofix JSON files.

#+BEGIN_SRC bash :tangle no
npm i -g json-fix
#+END_SRC

#+BEGIN_SRC elisp
(defun json-fix ()
  "Autofix json buffer"
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     (template "json-fix --no-sort --spaces <<tab-width>>") (current-buffer) t)))
#+END_SRC

*** Git Review

Config for [[https://github.com/charignon/github-review][charignon/github-review]].

**** Open Forge PR in Review Mode
#+BEGIN_SRC elisp
(defun +forge-start-pull-review ()
  "Start Pull Review on the current pull request"
  (interactive)
  (-some-->
   (forge-get-url (or (forge-post-at-point)
                      (forge-current-topic)))
   (let ((github-review-review-folder (or (directory-file-name (projectile-project-root)) github-review-review-folder)))
     (setq github-review-review-folder (directory-file-name (projectile-project-root)))
     (message "FOLDER: %s" github-review-review-folder)
     (github-review-start it))))
#+END_SRC

*** Indium
#+BEGIN_SRC elisp
(def-package! indium
  :config
  (setq indium-chrome-executable "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary"))
#+END_SRC
*** Prodigy
#+BEGIN_SRC elisp
(after! prodigy
  (define-key prodigy-mode-map "q" #'doom/escape)
  (define-key prodigy-mode-map "j" #'prodigy-next)
  (define-key prodigy-mode-map "k" #'prodigy-prev)
  (define-key prodigy-mode-map "G" #'prodigy-last)
  (let ((external-url (shell-command-to-string "echo -n $(ifconfig en0 | awk '$1 == \"inet\" {print \"http://\" $2}'):3001")))
    (prodigy-define-service
      :name "mindmeister-web"
      :url "localhost:3000"
      :command "npm"
      :args '("start")
      :path '("~/.nvm/versions/node/v8.8.1/bin")
      :cwd "~/Code/Meisterlabs/mindmeister-web"
      :tags '(mindmeister frontend))
    (prodigy-define-service
      :name "mindmeister-web production"
      :command "npm"
      :url external-url
      :args (list "run" "start" "PrivateMaps" "--" "--production" "--mmEndpoint" external-url)
      :path '("~/.nvm/versions/node/v8.8.1/bin")
      :cwd "~/Code/Meisterlabs/mindmeister-web"
      :tags '(mindmeister frontend production))
    (prodigy-define-service
      :name "mindmeister"
      :url "localhost:3001"
      :command "rails"
      :args '("s" "-p" "3000")
      :cwd "~/Code/Meisterlabs/mindmeister")
    (prodigy-define-service
      :name "meistercanvas"
      :url "localhost:7007"
      :command "npm"
      :args '("run" "start" "meistercanvas" "--" "--port" "7007")
      :path '("~/.nvm/versions/node/v8.8.1/bin")
      :cwd "~/Code/Meisterlabs/meistercanvas")))
#+END_SRC
*** Lookup
#+BEGIN_SRC elisp
(setq +lookup-provider-url-alist
  '(("DuckDuckGo"        . "https://duckduckgo.com/?q=%s")
    ("DuckDuckGo Lucky"  . "https://duckduckgo.com/?q=\\%s")
    ("Github Code"       . "https://github.com/search?search&q=%s&type=Code")
    ("Google"            . "https://google.com/search?q=%s")
    ("Google images"     . "https://google.com/images?q=%s")
    ("Google maps"       . "https://maps.google.com/maps?q=%s")
    ("NPM"               . "https://npmjs.com/search?q=%s")
    ("Hoogle"            . "https://www.haskell.org/hoogle/?hoogle=%s")
    ("Project Gutenberg" . "http://www.gutenberg.org/ebooks/search/?query=%s")
    ("DevDocs.io"        . "https://devdocs.io/#q=%s")
    ("Explain Shell"     . "https://explainshell.com/explain?cmd=%s")
    ("StackOverflow"     . "https://stackoverflow.com/search?q=%s")
    ("Github"            . "https://github.com/search?ref=simplesearch&q=%s")
    ("Youtube"           . "https://youtube.com/results?aq=f&oq=&search_query=%s")
    ("Wolfram alpha"     . "https://wolframalpha.com/input/?i=%s")
    ("Wikipedia"         . "https://wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")))
#+END_SRC
*** Smerge Mode
#+BEGIN_SRC elisp
(after! smerge-mode
  :config
  ;; TODO This is broken after switching the theme but works for now
  ;; This fixes the smerge diff color is really bright an ugly
  (set-face-attribute 'smerge-refined-added nil :foreground nil :background nil))
#+END_SRC
*** Workspaces
#+BEGIN_SRC elisp
;; Always create workspace when switching to project
(setq +workspaces-on-switch-project-behavior t)
#+END_SRC
*** Nov (Epub Reading Mode)

Adds epub reading mode
[[https://github.com/wasamasa/nov.el][wasamasa/nov.el: Major mode for reading EPUBs in Emacs]]

I want to keep the buffer centered, but let nov take care of breaking the text,
since this is much nicer then ~visual-line-mode~.

#+BEGIN_SRC elisp
(defun my-nov-config ()
  (setq line-spacing 5)
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif" :height 1.4)
  (setq visual-fill-column-center-text t)
  (setq visual-fill-column-width (+ nov-text-width 25))
  (visual-fill-column-mode t))

(def-package! nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (setq nov-text-width 75)
  :config
  (progn
    (add-hook 'nov-mode-hook 'my-nov-config)))
#+END_SRC

The font can be installed via brew cask.

#+BEGIN_SRC bash :tangle no
brew tap homebrew/cask-fonts
brew cask install font-liberation-sans
#+END_SRC
*** PDF Tools
**** PDF Tool Config
#+BEGIN_SRC elisp
;; Enable Retina pdfs
(setq pdf-view-use-scaling t)

;; Fix midnight colors for doom-one theme
(setq pdf-view-midnight-colors '("#BBC2CD" . "#282C34"))
#+END_SRC
*** LSP
**** Disable LSP hover
#+BEGIN_SRC elisp
(def-package! lsp-mode
  :config
  (setq lsp-eldoc-render-all nil
        lsp-eldoc-enable-hover nil
        lsp-eldoc-enable-signature-help nil
        lsp-eldoc-prefer-signature-help nil
        lsp-inhibit-message t
        lsp-highlight-symbol-at-point nil
        ;; Disable make error highlighting
        lsp-prefer-flymake nil))
#+END_SRC
**** Disable LSP hover face

#+BEGIN_SRC elisp
(add-hook! 'doom-load-theme-hook
  (after! lsp
    (dolist (face '(lsp-face-highlight-read
                    lsp-face-highlight-write
                    lsp-face-highlight-textual))
      (set-face-attribute
       face nil
       :foreground nil :distant-foreground nil :background nil))))
#+END_SRC
*** Ivy
**** Counsel Config
#+BEGIN_SRC elisp
(defun counsel-org-doom-config ()
  "Counsel the doom config"
  (interactive)
  (doom/find-private-org-config)
  (counsel-org-goto))
#+END_SRC

**** Import JS File
#+BEGIN_SRC elisp
;; TODO Make template accepts a cursor placeholder
;; TODO Maybe even look at exports
(defun my-js-import-file (file)
  (let ((cursor-postion (point))
        (filename (remove-js-ext file)))
    (insert (template "import  from '<<filename>>';"))
    (goto-char cursor-postion)
    (forward-char 7)
    (evil-insert-state)))

(defun +js|ivy-import-file (&optional action)
  (interactive)
  (ivy-read "Import file "
            (append
             (--map (concat "./" it)
                    (split-string (shell-command-to-string (concat find-program " " counsel-file-jump-args)) "\n" t))
             (split-string (shell-command-to-string
                            (concat "jq -r '.dependencies | keys | .[]' " (concat (projectile-project-root) "package.json"))) "\n" t))
            :action (or action 'my-js-import-file)))

(setq +MM-comment-headers '("EXTERNALS" "LOCALS" "HELPERS" "MAIN"))

(defun +MM:get-remaining-headers-list (header)
  "Returns a reversed list of headers to search through"
  (->> +MM-comment-headers
       (-split-on header)
       (-first-item)))

(defun +MM:goto-or-add-header (header)
  "Goes to a comment header or if it doesnt exist creates one"
  (goto-char (point-min))
  (if (search-forward header nil t)
      (progn
        (search-forward-regexp "^/\\*\\*" nil t)
        (previous-line 2))
    ;; Create header when none was found
    (progn
      (let* ((headers (reverse (+MM:get-remaining-headers-list header))))
        (--first (search-forward it nil t) headers))
      (search-forward-regexp "^/\\*\\*" nil t)
      (evil-insert-newline-above)
      (insert (template  "/** <<header>> **/\n\n\n\n"))
      (previous-line 1))))

(defun +MM:add-import-to-file (file)
  (goto-char (point-min))
  (let* ((is-local (s-contains? "./" file))
         (comment-header-title (if is-local "LOCALS" "EXTERNALS")))
    (+MM:goto-or-add-header comment-header-title)
    (evil-insert-newline-below)
    (previous-line 1)
    (my-js-import-file file)))

(defun +MM|import-file ()
  (interactive)
  (+js|ivy-import-file '+MM:add-import-to-file))
 #+END_SRC

**** Rules
#+BEGIN_SRC elisp :tangle no
(setq +MM-Rules
      (ht ("flexDirection"     '("row" "row-reverse" "column" "column-reverse"))
          ("fontWeight"        '("normal" "regular" "heavy" "bold" "black" "light"))
          ;; ("position"        '("absolute" "relative" "fixed"))
          ;; ("padding"           'number)
          ;; ("paddingHorizontal" 'number)
          ;; ("paddingVertical"   'number)
          ;; ("paddingTop"        'number)
          ;; ("paddingBottom"     'number)
          ;; ("paddingLeft"       'number)
          ;; ("paddingRight"      'number)
          ;; ("margin"            'number)
          ;; ("marginTop"         'number)
          ;; ("marginBottom"      'number)
          ;; ("marginLeft"        'number)
          ;; ("marginRight"       'number)
          ;; ("top"               'number)
          ;; ("left"              'number)
          ;; ("right"             'number)
          ;; ("bottom"            'number)
          ;; ("translateY"            'number)
          ;; ("translateX"            'number)
          ;; ("rotate"            'number)
          ;; ("absolute"       'noop)
          ;; ("absoluteHorizontalCenter"       'noop)
          ;; ("absoluteHorizontalCenter"       'noop))

    ;; ("absoluteCenter" 'noop)
    ;; ("absoluteHorizontalCenter" 'noop)
    ;; ("absoluteVerticalCenter" 'noop)
    ;; ("alignContent" '("flex-start", "flex-end", "center", "space-between", "space-around", "stretch"))
    ;; ("alignItems" '())
    ;; ("alignSelf" 'number)
    ;; ("assoc" 'number)
    ;; ("backfaceVisibility" 'number)
    ;; ("backgroundColor" 'number)
    ;; ("backgroundImage" 'number)
    ;; ("backgroundPosition" 'number)
    ;; ("backgroundRepeat" 'number)
    ;; ("backgroundSize" 'number)
    ;; ("borderBottomLeftRadius" 'number)
    ;; ("borderBottomRightRadius" 'number)
    ;; ("borderBottomWidth" 'number)
    ;; ("borderColor" 'number)
    ;; ("borderHorizontalWidth" 'number)
    ;; ("borderLeftWidth" 'number)
    ;; ("borderRadius" 'number)
    ;; ("borderRightWidth" 'number)
    ;; ("borderStyle" 'number)
    ;; ("borderTopLeftRadius" 'number)
    ;; ("borderTopRightRadius" 'number)
    ;; ("borderTopWidth" 'number)
    ;; ("borderVerticalWidth" 'number)
    ;; ("borderWidth" 'number)
    ;; ("bottom" 'number)
    ;; ("boxShadow" 'number)
    ;; ("boxShadows" 'number)
    ;; ("boxShadows.result" 'number)
    ;; ("boxSizing" 'number)
    ;; ("color" 'number)
    ;; ("concat" 'number)
    ;; ("concatWhen" 'number)
    ;; ("cursor" 'number)
    ;; ("display" 'number)
    ;; ("dissoc" 'number)
    ;; ("fill" 'number)
    ;; ("flexBasis" 'number)
    ;; ("flexDirection" 'number)
    ;; ("flexGrow" 'number)
    ;; ("flexShrink" 'number)
    ;; ("flexWrap" 'number)
    ;; ("float" 'number)
    ;; ("fontFamily" 'number)
    ;; ("fontSize" 'number)
    ;; ("fontStyle" 'number)
    ;; ("fontWeight" 'number)
    ;; ("fontWeight.Schema() callback" 'number)
    ;; ("fontWeight.caseEquals('black') callback" 'number)
    ;; ("fontWeight.caseEquals('heavy') callback" 'number)
    ;; ("fontWeight.caseEquals('light') callback" 'number)
    ;; ("fontWeight.caseEquals('regular') callback" 'number)
    ;; ("fontWeight.default() callback" 'number)
    ;; ("fontWeight.fold() callback" 'number)
    ;; ("height" 'number)
    ;; ("init" 'number)
    ;; ("justifyContent" 'number)
    ;; ("left" 'number)
    ;; ("lineHeight" 'number)
    ;; ("listStyleType" 'number)
    ;; ("margin" 'number)
    ;; ("marginBottom" 'number)
    ;; ("marginHorizontal" 'number)
    ;; ("marginLeft" 'number)
    ;; ("marginRight" 'number)
    ;; ("marginTop" 'number)
    ;; ("marginVertical" 'number)
    ;; ("maxHeight" 'number)
    ;; ("maxSize" 'number)
    ;; ("maxWidth" 'number)
    ;; ("merge" 'number)
    ;; ("minHeight" 'number)
    ;; ("minSize" 'number)
    ;; ("minWidth" 'number)
    ;; ("opacity" 'number)
    ;; ("overflow" 'number)
    ;; ("overflowX" 'number)
    ;; ("overflowY" 'number)
    ;; ("padding" 'number)
    ;; ("paddingBottom" 'number)
    ;; ("paddingHorizontal" 'number)
    ;; ("paddingLeft" 'number)
    ;; ("paddingRight" 'number)
    ;; ("paddingTop" 'number)
    ;; ("paddingVertical" 'number)
    ;; ("pointerEvents" 'number)
    ;; ("position" 'number)
    ;; ("resize" 'number)
    ;; ("right" 'number)
    ;; ("rotate" 'number)
    ;; ("scale" 'number)
    ;; ("scaleX" 'number)
    ;; ("scaleY" 'number)
    ;; ("schema" 'number)
    ;; ("size" 'number)
    ;; ("stretch" 'number)
    ;; ("stroke" 'number)
    ;; ("tableLayout" 'number)
    ;; ("textAlign" 'number)
    ;; ("textDecoration" 'number)
    ;; ("textOverflow" 'number)
    ;; ("textRendering" 'number)
    ;; ("textShadow" 'number)
    ;; ("textTransform" 'number)
    ;; ("top" 'number)
    ;; ("translate" 'number)
    ;; ("translateX" 'number)
    ;; ("translateY" 'number)
    ;; ("truncate" 'number)
    ;; ("userSelect" 'number)
    ;; ("verticalAlign" 'number)
    ;; ("visibility" 'number)
    ;; ("whiteSpace" 'number)
    ;; ("width" 'number)
    ;; ("wordBreak" 'number)
    ;; ("wordWrap" 'number)
    ;; ("zIndex" 'number))

(defvar +MM|add-prop-for-rule-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-<return>") (lambda (rule prop)
                                         (ivy-quit-and-run
                                           (progn
                                            (+MM|write-rule rule prop)
                                            (+MM|add-rule)))))
    map))

(defun +MM|write-rule (rule prop)
    (insert (template ".<<rule>>('<<prop>>')\n")))

(defun +MM|add-prop-for-rule (rule)
  (ivy-read "Add prop" (ht-get +MM-Rules rule)
            ;; :keymap counsel-find-file-map
            :action (lambda (prop) (+MM|write-rule rule prop)
                                   (+MM|add-rule))))

(defun +MM|add-rule ()
  (interactive)
  (ivy-read "Add Rule" (ht-keys +MM-Rules)
            :action '+MM|add-prop-for-rule))
#+END_SRC
**** Ivy Projectile

Override the default ~+default/search-project~, since that does just a basic rg, without respecting the
projectile ignores.

#+BEGIN_SRC elisp
(defun +default/search-project (&optional arg)
  "Conduct a text search in the current project root.
If prefix ARG is set, prompt for a known project to search from."
  (interactive "P")
  (let ((default-directory
          (if arg
              (if-let* ((projects (projectile-relevant-known-projects)))
                  (completing-read "Switch to project: " projects
                                   nil t nil nil (doom-project-root))
                (user-error "There are no known projects"))
            default-directory)))
    (call-interactively #'counsel-projectile-rg)))
#+END_SRC

*** Minibuffer Maps
#+BEGIN_SRC elisp
;; Insert from the minibuffer
(define-key! ivy-minibuffer-map
  "C-c TAB" (λ! ()
             (ivy-kill-whole-line)
             (ivy-quit-and-run (yank))))
#+END_SRC
*** TODO Org Noter

[[https://github.com/weirdNox/org-noter][Org Noter]] is a tool to annotate pdfs.

**** Disable Org Noter keybindings

#+BEGIN_SRC elisp
(setq org-noter-notes-mode-map (make-sparse-keymap))
#+END_SRC

**** TODO Create custom bindings to insert a note

This overrides my insert subheading keybinding

#+BEGIN_SRC elisp :tangle no
(after! org
  (def-package! org-noter
    :config
    (map!
     :leader
     (:prefix "m"
       :desc "Org-noter-insert" :n "i" #'org-noter-insert-note))))
#+END_SRC
*** TODO Spelling

Flycheck with ~hunspell~ (which supports other languages better than the default ~ispell~)

With the latest brew update hunspell might be broken, here is how you fix it:

#+BEGIN_SRC bash :tangle no
ln -fs /usr/local/opt/readline/lib/libreadline.8.0.dylib /usr/local/opt/readline/lib/libreadline.7.dylib
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp :tangle no
(defun +flyspell|save-word ()
  "Save the current word to dictionary"
  (interactive)
  (let* ((current-location (point))
         (word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location))))

(after! flyspell
  (cond
   ((executable-find "hunspell")

    ;; For the switching, "german" has to be also in this alist
    (add-to-list 'ispell-hunspell-dict-paths-alist (list "german" (expand-file-name "~/Library/Spelling/de_AT.aff")))

    (setq ispell-program-name "hunspell"
          ispell-local-dictionary "en_US"
          ispell-really-hunspell t
          ispell-local-dictionary-alist
                  ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell
                  ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries
                  '(("english" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "personal,en_US") nil utf-8)
                    ("german"  "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "personal,de_AT") nil utf-8))))))

(defun flyspell-set-language-environment ()
  "Change flyspell language based on the language environment"
  (cond
   ((string= "English" current-language-environment)
    (setq ispell-local-dictionary "english"))
   ((string= "German" current-language-environment)
    (setq ispell-local-dictionary "german"))))

(add-hook 'set-language-environment-hook 'flyspell-set-language-environment)
#+END_SRC
** Languages
*** Javascript
#+BEGIN_SRC elisp
(setq
 flycheck-javascript-eslint-executable (executable-find "eslint_d")
 flycheck-disabled-checkers '(javascript-jshint javascript))

(after! rjsx-mode
  (add-hook 'js2-mode-hook #'eslintd-fix-mode)
  (map! :map rjsx-mode-map
        :localleader
        (:desc "Open Self-Closing Tag" :n ">" #'+rjsx|expand-insert-self-closing-tag)
        (:desc "Open Self-Closing Tag" :n "<" #'rjsx-rename-tag-at-point)))

(after! js2-mode
  (add-hook 'js2-mode-hook #'eslintd-fix-mode)
  :config
  (map! :map js2-mode-map
        :localleader
        (:desc "import" :n "i" #'+js|ivy-import-file)
        (:desc "Indium" :prefix "I"
          :desc "Reload" :n  "r" #'indium-reload
          :desc "Start" :n  "s" #'indium-connect)))

(defun remove-js-ext (f)
  "Remove js extension from string"
  (replace-regexp-in-string "\.js$" "" f))

(defun buffer-file-name-relative ()
  "Extranct the filename with extension from path"
  (replace-regexp-in-string (file-name-directory buffer-file-name) "" (buffer-file-name)))

(defun match-const-function-name (line)
  "Matches a line to the word after the declaration"
  (nth 2 (s-match
          "\\(const\\|let\\|class\\)\s\\(.+?\\)\s"
          line)))

(defun const-function-at-point ()
  "Returns the current function name at the current line"
  (match-const-function-name (thing-at-point 'line t)))

(defun js2r-export-default ()
  "Exports the current declaration at the end of the file"
  (interactive)
  (save-excursion
    (let* ((name (const-function-at-point)))
      (goto-char (point-max))
      (insert "\n")
      (insert (template "export default <<name>>;")))))

(defun js2r-extract-const-to-file ()
  "Extracts function to external file"
  (interactive)
  (let* ((name (const-function-at-point))
         (path (concat "./" name ".js")))
    (evil-digit-argument-or-evil-beginning-of-line)
    (js2r-kill)
    (f-write-text "" 'utf-8 path)
    (find-file path)
    (yank)))

(defun js-index-file-names (&optional actions-dir)
  "Get filenames from current buffers directory"
  (let ((fs (directory-files (or actions-dir default-directory) nil ".*\\.js")))
    (mapcar 'remove-js-ext
            (remove "index.js" fs))))

(defun +js|generate-index (&optional actions-dir)
  "Generate an index import file for files in directory"
  (interactive)
  (erase-buffer)
  (let* ((fs (js-index-file-names actions-dir)))
    (mapc (lambda (f) (insert "import " f " from './" f "';\n")) fs)
    (insert "\n")
    (insert "export default {\n")
    (mapc (lambda (f) (insert "    " f ",\n")) fs)
    (insert "};")))

(defun js2r-sexp-to-template-string ()
  "Wrap sexp into a template string"
  (interactive)
  (kill-sexp)
  (insert (concat "`${" (substring-no-properties (car kill-ring)) "}`"))
  (pop kill-ring))
#+END_SRC
**** Little Word Motion

#+BEGIN_SRC elisp
(defun +js|load-evil-camel-case-motion ()
  (require 'evil-little-word)
  (define-key evil-normal-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-normal-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "i M-w") 'evil-inner-little-word))

(after! rjsx-mode
  (+js|load-evil-camel-case-motion))

(after! js2-mode
  (+js|load-evil-camel-case-motion))
#+END_SRC
**** Javascript Text Objects

#+BEGIN_SRC elisp
(add-hook! js-mode
  (require 'evil-text-objects-javascript)
  (evil-text-objects-javascript/install))
#+END_SRC

**** Expand self closing tag

#+BEGIN_SRC elisp
(defun +rjsx|expand-insert-self-closing-tag ()
  "Opens the current tag at any position of the cursor and starts insert mode"
  (interactive)
  (search-forward "/>")
  (evil-backward-char)
  (call-interactively #'delete-backward-char)
  (call-interactively #'rjsx-electric-gt)
  (newline)
  (call-interactively #'evil-indent-line)
  (call-interactively #'evil-open-above))
#+END_SRC

*** Reason
#+BEGIN_SRC elisp
(defun rtop ()
  "Launch reason version of utop"
  (interactive)
  (cl-letf ((utop-command "rtop -emacs"))
    (utop)))

(def-package! reason-mode
  :mode "\\.rei?$"
  :commands (reason-mode)
  :config
  ;; Merlin eldoc is very slow with marking the whole type region
  ;; Just trigger it via C-c C-t
  (setq merlin-eldoc-doc nil)
  (let* (
         (refmt-bin (executable-find "refmt"))
         (merlin-bin (executable-find "ocamlmerlin"))
         (merlin-base-dir (when merlin-bin
                            (replace-regexp-in-string "bin/ocamlmerlin$" "" merlin-bin))))
    ;; Add npm merlin.el to the emacs load path and tell emacs where to find ocamlmerlin
    (when merlin-bin
      (add-to-list 'load-path (concat merlin-base-dir "share/emacs/site-lisp/"))
      (setq merlin-command merlin-bin))

    (when refmt-bin
      (setq refmt-command refmt-bin))
    (require 'merlin)
    (add-hook! reason-mode
        (add-hook 'before-save-hook #'refmt-before-save nil t)
        (merlin-mode))
    (setq-hook! reason-mode
        indent-region-function #'apply-refmt)
    (set-electric! 'some-mode :chars '(?|))
    (set-lookup-handlers! 'reason-mode
                          :definition #'merlin-locate
                          :references #'merlin-occurrences
                          :documentation #'merlin-document)
    (set-company-backend! 'reason-mode 'merlin-company-backend)))
#+END_SRC
*** Markdown

Always keep markdown centered, without line numbers.

#+BEGIN_SRC elisp
(def-package! markdown-mode
  :init
  (setq markdown-fontify-code-blocks-natively t)
  :config
  (add-hook! markdown-mode
    (visual-line-mode)
    (visual-fill-column-mode)
    (outline-minor-mode)
    (setq visual-fill-column-width 90
          display-line-numbers nil)
    (setq line-spacing 2
          fill-column 80))

  (map! (:map markdown-mode-map
          :n "<"    #'markdown-promote
          :n ">"    #'markdown-demote)))
#+END_SRC
** Org
*** Utils
**** TODO Archive all done tasks
#+BEGIN_SRC elisp :tangle no
(defun my-archive-entry ()
  (message "%s" (thing-at-point 'line t)))

(defun +org|org-archive-done-tasks ()
  (interactive)
  (org-map-entries #'my-archive-entry "/[X]" 'tree))

(defun +org|org-archive-done-task ()
  (interactive)
  (org-map-entries (lambda (file) (message file)) "/[X]" 'file))

#+END_SRC
**** Grab Tablist from Chrome
#+BEGIN_SRC elisp
(defun +org|grab-tabs ()
  "Grab all the chrome tabs as an org list to save for later inspection"
  (interactive)
  (let ((tabs
         (do-jxa-script
          (concat
           "Application(\"Chrome\").windows[0].tabs()"
           ".map(tab => `"
           "- [[${tab.url()}][${tab.title()}]]"
           "`)"
           ".join(\"\\n\")"))))
    (insert tabs)))
#+END_SRC
**** Paste Chrome Link Fix

Fixes wrong paste behaviour where the link would be inserted directly on the character by adding a space

E.g.: (Brackets signal the cursor position)

: **[*]
: ***[]"

#+BEGIN_SRC elisp
(defun +org|paste-chrome-link ()
  "Paste the frontmost chrome link"
  (interactive)
  (unless (looking-at-p "[\s\t\n\r]") (forward-char))
  (insert " ")
  (insert (org-mac-chrome-get-frontmost-url)))
#+END_SRC
**** Sort org entries
#+BEGIN_SRC elisp
(defun +org|sort-entries ()
  "Go to header and sort entries"
  (interactive)
  (org-up-element)
  (org-sort)
  (org-shifttab)
  (org-cycle))
#+END_SRC
**** Copy block to clipboard
#+BEGIN_SRC elisp
(defun +org|copy-block ()
  "Copies the current block to clipboard"
  (interactive)
  (org-edit-src-code)
  (clipboard-kill-ring-save (point-min) (point-max)))
#+END_SRC
**** Paste Markdown as org
#+BEGIN_SRC elisp
(defun +org|paste-markdown-as-org ()
  "Convert the current clipboard to markdown"
  (interactive)
  (insert (shell-command-to-string "pbpaste | pandoc -f markdown -t org")))
#+END_SRC
**** Ocaml Refmt to Reason
#+BEGIN_SRC elisp
(defun +org|org-src-block-refmt-reason-ocaml-toggle ()
  "Convert the current src block from ocaml to reason and vice versa"
  (interactive)
  (save-excursion
    (let* ((old-block (org-element-at-point))
           (old-lang (org-element-property :language old-block))
           (new-lang (if (string= old-lang "ocaml") "reason" "ocaml"))
           (formatter (if (string= old-lang "ocaml") 'refmt-region-ocaml-to-reason 'refmt-region-reason-to-ocaml)))
      (org-edit-special)
      (funcall formatter (point-min) (point-max))
      (org-edit-src-exit)
      (let* ((new-block (org-element-at-point))
             (new-block-parsed (org-element-interpret-data (org-element-put-property (org-element-at-point) :language new-lang)))
             (from (org-element-property :begin new-block))
             (to (org-element-property :end new-block)))
        (delete-region from to)))))
#+END_SRC
**** Archive and Done
#+BEGIN_SRC elisp
(defun org-archive-and-done ()
  "Mark task as done and archive"
  (interactive)
  (org-todo "DONE")
  (org-archive-subtree))
#+END_SRC
*** Config Rifle
#+BEGIN_SRC elisp
(defun helm-org-rifle-config ()
  "Rifle for the literate configuration file"
  (interactive)
  (helm-org-rifle-files (list +literate-config-file)))
#+END_SRC
*** Org Attach
**** Download
#+BEGIN_SRC elisp
(defun +org-attach/downloads-file (file)
  "Attach a file in your downloads-directory"
  (interactive (list (read-file-name "Attach File: " downloads-dir)))
  (+org-attach/uri file))
#+END_SRC
**** Screenshot
#+BEGIN_SRC elisp
(defun +org-attach/last-screenshot ()
  "Attaches the last screenshot"
  (interactive)
  (+org-attach/file (latest-file screenshot-dir)))
#+END_SRC
*** Config
**** General Config
***** Todo Keywords
#+BEGIN_SRC elisp
(after! org
  :config
  (setq org-todo-keywords
        '((sequence "ACTIVE(a)" "NEXT(n)" "|" "DONE")
          (sequence "TODO(T)" "|" "DONE(X)")
          (sequence "[ ](t)" "|" "[X](x)")
          (sequence "PROJECT(p)" "|" "DONE")
          (sequence "WAITING(w)" "LATER(l)" "SOMEDAY(s)" "|" "DONE" "CANCELLED(c)"))
   org-todo-keyword-faces
   '(("ACTIVE" :inherit warning :weight bold)
     ("NEXT" :inherit warning :weight bold)
     ("WAITING" :inherit default :weight bold)
     ("SOMEDAY" :inherit default :weight bold)
     ("LATER" :inherit default :weight bold)
     ("PROJECT" :inherit 'org-todo :weight bold))))
#+END_SRC
***** Projectile Ignore

#+BEGIN_SRC elisp
(after! projectile
  (add-to-list 'projectile-globally-ignored-file-suffixes ".org_archive")
  (add-to-list 'projectile-globally-ignored-file-suffixes ".DS_Store"))
#+END_SRC

***** Org variables

#+BEGIN_SRC elisp
(setq
 org-directory (expand-file-name "~/Dropbox/org")
 org-pinboard-dir org-directory
 org-pinboard-file (concat org-pinboard-dir "/Bookmarks/bookmarks.org")
 org-pinboard-archive-file (concat org-pinboard-dir "/Bookmarks/.archive/pinboard.org")
 org-default-notes-file (concat org-directory "/inbox.org")
 org-shopping-list-file (concat org-directory "/shoppinglist.org")
 org-reading-list (concat org-directory "/reading-list.org"))

(after! org
  :config
  (setq
   org-tags-column (- fill-column)
   org-image-actual-width 600
   org-default-notes-file (concat org-directory "/inbox.org")))
#+END_SRC
***** Latex
Needs ~dvisvgm~

#+BEGIN_SRC elisp
(setq org-latex-create-formula-image-program 'dvisvgm)
#+END_SRC

**** Export
#+BEGIN_SRC elisp
(defun +org|copy-subtree-as-markdown ()
  "Copy the current subtree as markdown to clipboard"
    (interactive)
    (let* ((org-export-with-toc nil)
           (md (org-md-export-as-markdown nil t)))
      (kill-ring-save (point-min) (point-max))
      (kill-buffer md)))
#+END_SRC
**** Tags
***** Tags List

Not sure yet if the shortcuts work for me.
Maybe just try persistent tags.

#+BEGIN_SRC elisp
(setq
 org-tag-persistent-alist '(("ACCESABILTY"))
 org-tag-alist '(("CSS" . ?c)
                 ("DESIGN" . ?d)
                 ("EMACS" . ?e)
                 ("GUIDE" . ?g)
                 ("HASKELL" . ?h)
                 ("JAVASCRIPT" . ?j)
                 ("LEISURE" . ?l)
                 ("MATH" . ?m)
                 ("REASON_ML" . ?r)
                 ("REPOSITORY". ?R)
                 ("WORK" . ?w)))
#+END_SRC
***** Tags Helpers
#+BEGIN_SRC elisp
(defun +org-align-all-tags ()
  "Interactive version of org-align-all-tags"
  (interactive)
  (org-align-all-tags))
#+END_SRC
**** Refile Targets

#+BEGIN_SRC elisp
(defun expand-org-file-names (xs)
  (mapcar (λ (x) (expand-file-name x org-directory)) xs))

(setq level-1-refile-targets (expand-org-file-names '("reading-list.org"
                                                      "cooking.org"
                                                      ;; "books.org"
                                                      "programming.org"
                                                      "shoppinglist.org")))

(setq max-level-2-refile-targets (expand-org-file-names '("Emacs.org"
                                                          "art.org"
                                                          "diary"
                                                          "games.org"
                                                          "hardware.org"
                                                          "home.org"
                                                          "inbox.org"
                                                          "mealplan.org"
                                                          "misc.org"
                                                          "movies.org"
                                                          "music.org"
                                                          "osx.org"
                                                          "personal.org"
                                                          "podcasts.org"
                                                          "projects.org"
                                                          "sleep.org"
                                                          "sports.org"
                                                          "travel.org"
                                                          "Work/work.org")))

(defun level-1-refile-targets () level-1-refile-targets)

(defun max-level-2-refile-targets () max-level-2-refile-targets)

(after! org
  :config
  (setq org-refile-targets (quote ((nil :maxlevel . 5)
                                   (max-level-2-refile-targets :maxlevel . 2)
                                   (level-1-refile-targets :level . 1)))
        org-agenda-refile org-agenda-files))
#+END_SRC
**** Journal
#+BEGIN_SRC elisp
(defvar org-journal-dir-default "~/Dropbox/org/journal")
(defvar org-journal-dir-diary "~/Dropbox/org/diary")

(setq org-journal-dir org-journal-dir-default)
(setq org-journal-file-format "%Y-%m-%d")
(setq org-journal-date-prefix "#+TITLE: ")
(setq org-journal-date-format "%A, %B %d %Y")
(setq org-journal-time-prefix "* ")
(setq org-journal-time-format "")
#+END_SRC
**** Org Capture
***** Org Capture Config

#+BEGIN_SRC elisp
(setq +org-capture-frame-parameters
  `((name . "org-capture")
    (width . 120)
    (height . 35)
    (transient . t)))
#+END_SRC

***** Org Capture Templates

#+BEGIN_SRC elisp
(defun org-capture-bookmark-pair ()
  (split-string (org-as-mac-chrome-get-frontmost-url) "::split::"))

(defun org-capture-bookmark-string-url ()
  (car (org-capture-bookmark-pair)))

(defun org-capture-bookmark-string-description ()
  (cadr (org-capture-bookmark-pair)))

(after! org
  :config
  (setq org-capture-templates
        `(("t" "todo" entry
           (file org-default-notes-file)
           "* TODO %?\n%U")

          ("c" "Calendar Event" entry
           (file+headline ,(concat org-directory "/home.org") "Calendar")
           "* %?\n%U")

          ("e" "Emacs Todo" entry
           (file+headline ,(concat org-directory "/emacs.org") "Emacs Todos")
           "* TODO %?\n%U")

          ("p" "Pin Bookmark" entry (file+headline org-pinboard-file "Pinboard")
           "* %(org-capture-bookmark-string-description)%?\n:PROPERTIES:\n:URL:  %(org-capture-bookmark-string-url)\n:TIME: %U\n:END:")

          ("C" "Browser" entry
           (file org-default-notes-file)
           "* %(org-mac-chrome-get-frontmost-url)%?\n%U")

          ("w" "work" entry
           (file+headline ,(concat org-directory "/Work/work.org") "Todo ")
           "* TODO %?\n%U"))))
#+END_SRC
**** TODO Src Block Snippets

Solve these with yasnippet

#+BEGIN_SRC elisp :tangle no
(add-to-list 'org-structure-template-alist '("es" "#+BEGIN_SRC elisp\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("E" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE"))
(add-to-list 'org-structure-template-alist '("j" "#+BEGIN_SRC js\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("ps" "#+BEGIN_SRC purescript\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("b" "#+BEGIN_SRC bash\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("re" "#+BEGIN_SRC reason\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("oc" "#+BEGIN_SRC ocaml\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("rb" "#+BEGIN_SRC ruby\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("md" "#+BEGIN_SRC markdown\n?\n#+END_SRC\n"))
#+END_SRC

**** TODO Bookmarks
These can be solved with a lambda and dont need extra functions
#+BEGIN_SRC elisp
(defun org-find-file (f)
  "Find file in org directory"
  (find-file (concat org-directory f)))

(defun +org|org-open-home-file ()
  "Open the home org file"
  (interactive)
  (org-find-file "/home.org"))

(defun +org|org-open-reading-list-file ()
  "Open the reading list org file"
  (interactive)
  (org-find-file "/reading-list.org"))

(defun +org|org-open-work-file ()
  "Open the home org file"
  (interactive)
  (org-find-file "/Work/work.org"))
#+END_SRC

**** Leader Bindings
#+BEGIN_SRC elisp
(map! :leader (:desc "Notes" :prefix "n"
                :desc "Pinboard File"        :n "B" (λ! (find-file org-pinboard-file))
                :desc "Save All Org Buffers" :n "S" #'org-save-all-org-buffers
                :desc "Agenda"               :n "a" #'org-agenda
                :desc "Search Pinboard"      :n "b" #'helm-org-pinboard
                :desc "Emacs"                :n "e" (λ! (find-file (concat org-directory "/Emacs.org")))
                :desc "Home"                 :n "h" #'+org|org-open-home-file
                :desc "Inbox"                :n "i" (λ! (find-file (concat org-directory "/inbox.org")))
                :desc "Reading List"         :n "r" #'+org|org-open-reading-list-file
                :desc "Work"                 :n "w" #'+org|org-open-work-file
                :desc "Store Link"           :n "y" #'org-store-link))
#+END_SRC
**** General Bindings
#+BEGIN_SRC elisp
(after! org
  (map! :map evil-org-mode-map
        :n "s-j" #'org-move-subtree-down
        :n "s-k" #'org-move-subtree-up

        :localleader
        :desc "Archive Subtree"          :m "a" #'org-archive-subtree
        :desc "Archive Subtree and Done" :m "A" #'org-archive-and-done
        :desc "Paste Chrome Link"        :m "p" #'+org|paste-chrome-link
        :desc "Grab tabs"                :m "P" #'+org|grab-tabs
        :desc "Cut Subtree"              :m "C" #'org-cut-subtree
        :desc "Paste Subtree"            :m "P" #'org-paste-subtree
        :desc "Sort Entries"             :m "S" #'+org|sort-entries

        :desc "Create/Edit Todo"  :nve "o" #'org-todo
        :desc "Schedule"          :nve "s" #'org-schedule
        :desc "Deadline"          :nve "d" #'org-deadline
        :desc "Refile"            :nve "r" #'org-refile
        :desc "Filter"            :nve "f" #'org-match-sparse-tree
        :desc "Tag heading"       :nve "t" #'org-set-tags-command

        (:desc "Attach" :prefix "F"
          :desc "Downloads File" :m "d" '+org-attach/downloads-file
          :desc "Screenshot" :m "s" '+org-attach/last-screenshot
          :desc "URI" :m "u" '+org-attach/uri
          :desc "File" :m "f" '+org-attach/file)

        (:desc "Insert" :prefix "i"
          :desc "Subheadeing" :m "s" (λ!
                                      (call-interactively 'org-insert-subheading)
                                      (evil-insert-state))
          :desc "Inavtive Timestamp" :m "i" 'org-time-stamp-inactive)
        (:desc "Narrow" :prefix "n"
          :desc "Indirect Buffer Tree" :m "i" #'org-tree-to-indirect-buffer
          :desc "Subtree"              :m "s" #'org-narrow-to-subtree
          :desc "Block"                :m "b" #'org-narrow-to-block
          :desc "Element"              :m "e" #'org-narrow-to-element
          :desc "widen"                :m "w" #'widen)))
#+END_SRC
**** Agenda
***** Bindings
#+BEGIN_SRC elisp
(evil-define-key 'motion org-agenda-mode-map
  "vd" 'org-agenda-day-view
  "ds" 'org-agenda-schedule
  "vw" 'org-agenda-week-view
  "vm" 'org-agenda-month-view
  "vy" 'org-agenda-year-view)
#+END_SRC
***** Custom Agenda Commands

#+BEGIN_SRC elisp
(after! org-agenda
  (add-to-list 'org-agenda-custom-commands
               '("p" "Personal" agenda ""
                 ((org-agenda-ndays 5)
                  (org-agenda-span 7)
                  (org-agenda-tag-filter-preset '("-WORK" "-REPEATING"))
                  (tags-todo "-\[X\]")
                  (tags-todo "-DONE")
                  (org-agenda-start-on-weekday nil)
                  (org-agenda-time-grid nil)
                  (org-agenda-day-view)
                  (org-agenda-repeating-timestamp-show-all t))))
  (add-to-list 'org-agenda-custom-commands
               '("w" "Work" tags-todo "+WORK"))
  (add-to-list 'org-agenda-custom-commands
               '("rr" "Reading List" tags-todo "+TEXT"))
  (add-to-list 'org-agenda-custom-commands
               '("c" "Calendar" agenda ""
                 ((org-agenda-span 7)
                  (org-agenda-start-on-weekday nil)
                  (org-agenda-start-day "-1d")
                  (org-agenda-tag-filter-preset '("+CALENDAR")))))


  :config
  (setq org-agenda-files (list org-directory (concat org-directory "/Work"))))
#+END_SRC

Helper to reset the org agenda custom commands.

#+BEGIN_SRC elisp :tangle no
(setq org-agenda-custom-commands '())
#+END_SRC
** Package Config
*** Dired
**** Window targeting

When there are two visual splits with dired buffers.
~C~ will take the other window as the copy target.
The cursor has to be on the dired frame with the marked files.

#+BEGIN_SRC elisp
(setq dired-dwim-target t)
#+END_SRC

**** Disable dired from opening files in a new window
#+BEGIN_SRC elisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
**** Kill all dired buffers with ~Q~
#+BEGIN_SRC elisp
(defun +dired|kill-dired-buffers ()
  "Kills all dired buffers
Dired creates a buffer for every directory which it visits
Which is fine since you can easily switch between visited buffers
But at some time I want to purge those buffers"
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))

(map! :when (featurep! :editor evil +everywhere)
      :after dired
      :map dired-mode-map
      :n "Q" #'+dired|kill-dired-buffers)
#+END_SRC
**** Use gls

Use ~gls~ with dired which is way faster than osx ~ls~
Must enable =dired-k-human-readable= when =-h= flag is given.
Otherwise dired comes to a grinding halt on some sizes.

#+BEGIN_SRC elisp
(after!
  dired
  :config
  (when (and IS-MAC (locate-file "gls" exec-path))
    (setq dired-listing-switches "-la -h --group-directories-first"
          dired-k-human-readable t
          insert-directory-program "gls" dired-use-ls-dired t)))
#+END_SRC
**** Wdired Mode Switch

Stay in normal mode when switching to wdired

#+BEGIN_SRC elisp
(defun flosc|wdired-change-to-wdired-mode ()
  "Simple forward to wdired-change-to-wdired-mode, but staying in normal mode."
  (interactive)
  (wdired-change-to-wdired-mode)
  (evil-normal-state)
  (forward-char))
#+END_SRC

Map ~\~ to change to wdired mode, like text mode in maggit buffers.

#+BEGIN_SRC elisp
(map! :when (featurep! :editor evil +everywhere)
      :after dired
      :map dired-mode-map
      :n "\\" #'flosc|wdired-change-to-wdired-modej)
#+END_SRC
*** Treemacs
**** Treemacs Evil window switching
#+BEGIN_SRC elisp
(map!
 (:after treemacs-evil
   (:map evil-treemacs-state-map
     "C-h" #'evil-window-left
     "C-l" #'evil-window-right)))
#+END_SRC

**** Ignore ~happypack~                                                                              :HACK:

Happypack slows down treemacs quite a bit.

#+BEGIN_SRC elisp
(defun treemacs-is-file-happypack? (f _)
  (string= f ".happypack"))

(after! treemacs
  (add-to-list 'treemacs-ignored-file-predicates #'treemacs-is-file-happypack?))
#+END_SRC

*** Dired Recent
#+BEGIN_SRC elisp
(def-package! dired-recent
  :after dired
  :init
  :config
  (setq dired-recent-directories-file (concat doom-cache-dir "recentdir")
        dired-recent-max-directories 300)
  (dired-recent-mode 1))
#+END_SRC
*** Evil-Snipe
**** Repeat snipe after further key press
#+BEGIN_SRC elisp
(after! evil-snipe
  (setq evil-snipe-repeat-keys t))
#+END_SRC
*** Flycheck
**** Proselint
:PROPERTIES:
:SOURCE:   https://unconj.ca/blog/linting-prose-in-emacs.html
:END:

Adds proselint checker to flycheck.
Not sure if I like this yet, seems slow and too opinionated.

To install proselint you have to install it via pip3

#+BEGIN_SRC bash :tangle no
pip3 install proselint
#+END_SRC

To enable the checker press ~SPC u C-c ! x~

#+BEGIN_SRC elisp
(after! flycheck
  :config
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
        (id (one-or-more (not (any " "))))
        (message) line-end))
    :modes (text-mode markdown-mode gfm-mode))

  (add-to-list 'flycheck-checkers 'proselint))
#+END_SRC
*** EWW Web Browser
**** Set the max page width
#+BEGIN_SRC elisp
(setq shr-width 120)
#+END_SRC
*** Blimp
#+BEGIN_SRC elisp
(def-package! blimp
  :hook (image-mode-hook . blimp-mode))
#+END_SRC
*** Git Lens
#+BEGIN_SRC elisp
(def-package! git-lens
  :commands (git-lens))
#+END_SRC
*** Eshell
**** Aliases

Overrides dooms aliases.

#+BEGIN_SRC elisp
(setq +eshell-aliases
  '(("q"      "exit")
    ("f"      "find-file $1")
    ("bd"     "eshell-up $1")
    ("rg"     "rg --color=always $*")
    ("ag"     "ag --color=always $*")
    ("l"      "ls -lh")
    ("ll"     "ls -lah")
    ("gs"     "git status")
    ("gc"     "git commit")
    ("clear"  "clear-scrollback")))
#+END_SRC
**** Syntax highlighted cat
#+BEGIN_SRC elisp
(defun eshell/cat (file)
  "Like `cat' but output with Emacs syntax highlighting."
  (with-temp-buffer
    (insert-file-contents file)
    (let ((buffer-file-name file))
      (delay-mode-hooks
        (set-auto-mode)
        (if (fboundp 'font-lock-ensure)
            (font-lock-ensure)
          (with-no-warnings
            (font-lock-fontify-buffer)))))
    (buffer-string)))

(add-to-list '+eshell-aliases '("cat" "eshell/cat $1"))
#+END_SRC
** General Config
*** Disable Eldoc
#+BEGIN_SRC elisp
(global-eldoc-mode -1)
#+END_SRC
*** Open OTF fonts in image mode
#+BEGIN_SRC elisp
(add-to-list 'auto-mode-alist '("\\.otf\\'" . image-mode))
#+END_SRC
*** Shorten Yes/No prompts
:PROPERTIES:
:SOURCE:   https://github.com/wasamasa/dotemacs/blob/master/init.org#shorten-yesno-prompts
:END:

Per default you're required to type out a full "yes" or "no" whenever
the function ~yes-or-no-p~ is invoked, let's substitute its function
definition to allow a "y" or "n" without even requiring confirmation.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Fine undo
Whether actions like "cw" are undone in several steps.

#+BEGIN_SRC elisp
(setq evil-want-fine-undo t)
#+END_SRC
*** Move items to trash on delete
#+BEGIN_SRC elisp
(setq
 trash-directory "~/.Trash/"
 delete-by-moving-to-trash t)
#+END_SRC
*** Filename Auto Modes
Automatically set mode for specifc filenames

#+BEGIN_SRC elisp
;; auto-mode-alist
(add-to-list 'auto-mode-alist '("Brewfile" . shell-script-mode))
#+END_SRC
*** Terminal Config
Set the terminal to zsh

#+BEGIN_SRC elisp
;; Set the default multi-term to zsh
(setq multi-term-program "/bin/zsh")
#+END_SRC
*** Save Hist Mode
Save the command history between sessions
The history can be accessed with ~C-n~ / ~C-p~

#+BEGIN_SRC elisp
(savehist-mode 1)
#+END_SRC
*** Automatically reload tags files
#+BEGIN_SRC elisp
(setq tags-revert-without-query 1)
#+END_SRC
** Bindings
*** General Bindings
#+BEGIN_SRC elisp
(map! :en "C-±"   #'+popup/raise)
#+END_SRC
*** Mac Modifier Bindings
#+BEGIN_SRC elisp
(map! (:map override
        "s-x" #'execute-extended-command
        "s-w" #'+workspace/close-window-or-workspace
        "s-;" #'eval-expression)

      ;; Workspace Switching
      :niv "s-1" (λ! (+workspace/switch-to 0))
      :niv "s-2" (λ! (+workspace/switch-to 1))
      :niv "s-3" (λ! (+workspace/switch-to 2))
      :niv "s-4" (λ! (+workspace/switch-to 3))
      :niv "s-5" (λ! (+workspace/switch-to 4))
      :niv "s-6" (λ! (+workspace/switch-to 5))
      :niv "s-7" (λ! (+workspace/switch-to 6))
      :niv "s-8" (λ! (+workspace/switch-to 7))
      :niv "s-9" (λ! (+workspace/switch-to 9))

      ;; Text scale
      :niv "s-="   #'default-text-scale-increase
      :niv "s--"   #'default-text-scale-decrease
      :niv "s-0"   #'default-text-scale-reset)
#+END_SRC
*** Evil Normal Bindings
**** Window navigation
#+BEGIN_SRC elisp
(map!
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)
#+END_SRC
**** Replace With Register Motion
#+BEGIN_SRC elisp
(def-package! evil-replace-with-register
  :config
  (setq evil-replace-with-register-key (kbd "gr"))
  (define-key evil-normal-state-map
    evil-replace-with-register-key 'evil-replace-with-register)
  (define-key evil-visual-state-map
    evil-replace-with-register-key 'evil-replace-with-register))
#+END_SRC
**** Evil Quotes/Brackets Motion

Changes the text matching inside quotes with ~q~ motion (e.g. ~ciq~)
Change inner bracket with ~r~

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket))
#+END_SRC
**** Go up one directory from the current buffer
#+BEGIN_SRC elisp
(after! evil
  (map! :m  "-"  #'dired-jump))
#+END_SRC
**** Fix history navigation for the minibuffer
#+BEGIN_SRC elisp
(define-key minibuffer-local-map "\C-p" 'previous-history-element)
(define-key minibuffer-local-map "\C-n" 'next-history-element)
#+END_SRC
**** Jump to last buffer
#+BEGIN_SRC elisp
(map! :n "gb" #'evil-switch-to-windows-last-buffer)
#+END_SRC
*** Evil Square Bracket Bindings

Global ~[~ & ~]~ combinator bindings

**** Dumb Jump
#+BEGIN_SRC elisp
(map!
 :n "]f" #'dumb-jump-go
 :n "[f" #'dumb-jump-back)
#+END_SRC
**** Flycheck Error Jumping
#+BEGIN_SRC elisp
(map!
 :n "]e" #'flycheck-next-error
 :n "[e" #'flycheck-previous-error)
#+END_SRC
**** Insert Line above/below
#+BEGIN_SRC elisp
(evil-define-motion evil-motion-insert-newline-below (count)
  "Insert COUNT newlines below"
  :type line
  (save-excursion
    (dotimes (c (or count 1))
      (evil-insert-newline-below))))

(evil-define-motion evil-motion-insert-newline-above (count)
  "Insert COUNT newlines above"
  :type line
  (save-excursion
    (dotimes (c (or count 1))
      (evil-insert-newline-above))))

(after! evil
  (map! :n "[ SPC" #'evil-motion-insert-newline-above
        :n "] SPC" #'evil-motion-insert-newline-below))
#+END_SRC
*** Evil Insert Bindings

Insert Mode bindings, mostly unicode insertion and workaround for german umlaut.

**** Insert from the kill ring in insert mode

#+BEGIN_SRC elisp
(map! :i "A-y" #'helm-show-kill-ring)
#+END_SRC

**** Unicode Symbols and German Umlaut

#+BEGIN_SRC elisp
(map!
 :i "M-;"   (λ! (insert "ö"))
 :i "M-:"   (λ! (insert "Ö"))
 :i "M-'"   (λ! (insert "ä"))
 :i "M-\""  (λ! (insert "Ä"))
 :i "M-["   (λ! (insert "ü"))
 :i "M-{"   (λ! (insert "Ü"))
 :i "M-s"   (λ! (insert "ß"))
 :i "M-e"   (λ! (insert "€"))
 :i "M-`"   (λ! (insert "°"))
 :i "M-."   (λ! (insert "…"))
 :i "M-^"   (λ! (insert "°"))
 :i "M-l"   (λ! (insert "λ"))
 :i "M-w"   (λ! (insert "⚠"))
 :i "M-i"   (λ! (insert "ℹ")))
#+END_SRC
***** TODO Inserting a character makes one undo state
*** Leader Bindings

My global leader bindings

#+BEGIN_SRC elisp
(map!
 :leader
 :n "'"  #'+popup/toggle
 :n "au" #'undo-tree-visualize
 :n "//" #'+default/search-project
 :n "-"  #'quick-calc

 (:desc "Toggle last iBuffer" :n "=" #'+popup/toggle)

 (:desc "file" :prefix "f"
   :desc "find in literate config file" :n  "p" #'counsel-org-doom-config)

 (:desc "dir" :prefix "d"
   :desc "find in literate config file" :n  "r" #'dired-recent-open
   :desc "Project Root"                 :n  "p" (λ! (dired (projectile-project-root))))

 (:desc "git" :prefix "g"
   :desc "Amend Commit"                :n  "a" #'magit-commit-amend
   :desc "Checkout"                    :n  "b" #'magit-checkout
   :desc "Blame"                       :n  "B" #'magit-blame
   :desc "New Branch"                  :n  "N" #'magit-branch-spinoff
   :desc "Show revision original File" :n  "O" #'magit-revision-show-original-file)

 (:desc "insert" :prefix "i"
   :desc "Killring"   :n  "y" #'helm-show-kill-ring)

 (:desc "project" :prefix "p"
   :desc "services" :n  "s" #'prodigy
   :desc "Workspace Project Files" :n  "P" #'+workspace|find-workspace-project-file)

 (:desc "toggle" :prefix "t"
   :desc "Theme Dark/Light" :n  "t" #'+doom|toggle-theme)

 (:desc "open" :prefix "o"
   :desc "Eshell in Current Dir" :n  "." (λ! (+eshell/open t))
   :desc "Eshell Popup in Current Dir" :n  ">" (λ! (+eshell/open t)))

 (:desc "window" :prefix "w"
   :desc "Split Vertical" :n "|" #'evil-window-vsplit
   :desc "Split Horizontal" :n "_" #'evil-window-split)

 (:desc "workspace" :prefix "<tab>"
   :desc "Create"       :n "c" #'+workspace/new-named
   :desc "Rename"       :n "," #'+workspace/rename
   :desc "Last visited" :n "0" #'+workspace/switch-to-last-visited
   :desc "Clone"        :n "C" (λ!)
                         (+workspace/new (format "Clone: %s" (+workspace-current-name)) t)
                         (message "Cloned current workspace %s" (+workspace-current-name))

   :desc "Display tab bar"          "TAB" #'+workspace/display
   :desc "New workspace"            "n"   #'+workspace/new
   :desc "Load workspace from file" "l"   #'+workspace/load
   :desc "Save workspace to file"   "s"   #'+workspace/save
   :desc "Switch workspace"         "."   #'+workspace/switch-to
   :desc "Delete session"           "x"   #'+workspace/kill-session
   :desc "Delete this workspace"    "d"   #'+workspace/delete
   :desc "Rename workspace"         "r"   #'+workspace/rename
   :desc "Restore last session"     "R"   #'+workspace/restore-last-session
   :desc "Next workspace"           "]"   #'+workspace/switch-right
   :desc "Previous workspace"       "["   #'+workspace/switch-left
   :desc "Switch to 1st workspace"  "1"   (λ! (+workspace/switch-to 0))
   :desc "Switch to 2nd workspace"  "2"   (λ! (+workspace/switch-to 1))
   :desc "Switch to 3rd workspace"  "3"   (λ! (+workspace/switch-to 2))
   :desc "Switch to 4th workspace"  "4"   (λ! (+workspace/switch-to 3))
   :desc "Switch to 5th workspace"  "5"   (λ! (+workspace/switch-to 4))
   :desc "Switch to 6th workspace"  "6"   (λ! (+workspace/switch-to 5))
   :desc "Switch to 7th workspace"  "7"   (λ! (+workspace/switch-to 6))
   :desc "Switch to 8th workspace"  "8"   (λ! (+workspace/switch-to 7))
   :desc "Switch to 9th workspace"  "9"   (λ! (+workspace/switch-to 8))
   :desc "Switch to last workspace" "0"   #'+workspace/switch-to-last)

 (:desc "window" :prefix "w"
   :desc "Toggle Locked" :n "#" #'toggle-window-dedicated)

 (:desc "Yank" :prefix "y"
   :desc "filename"  :n  "f" (λ! (copy-message (file-name-nondirectory buffer-file-name)))
   :desc "base"      :n  "b" (λ! (copy-message (file-name-base (buffer-file-name))))
   :desc "directory" :n  "d" (λ! (copy-message (file-name-directory (buffer-file-name))))
   :desc "path"      :n  "p" (λ! (copy-message (file-name-directory (buffer-file-name))))
   :desc "project"   :n  "r" (λ! (copy-message (s-replace (projectile-project-root) "" (buffer-file-name))))))
#+END_SRC

*** Local Leader Bindings

Mode Specific local leader Bindings.
My local leader is ~SPC M~

**** Eshell
#+BEGIN_SRC elisp
(defun floscr|+eshell|init-keymap ()
  "Setup additional custom eshell keybindings to already existing doom bindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
  (map! :map eshell-mode-map
        :localleader "l" #'eshell/clear))
(add-hook 'eshell-first-time-mode-hook #'floscr|+eshell|init-keymap)
#+END_SRC
*** Package/Mode Bindings

Pacakge/Mode specific bindings

**** Org Mode
#+BEGIN_SRC elisp
(map!
 :niv "s-X"   #'+org-capture/open-frame)

(map! :map org-mode-map
      :localleader
      (:prefix ("g" . "goto")
        :desc "Org Web Link" "l" #'+org-web-tools/read-url-at-point))

(map! :map outline-mode-map
      :n "s-k" #'org-metaup
      :n "s-j" #'org-metadown)
#+END_SRC
**** Elisp
Slurp and Barf expressions

#+BEGIN_SRC elisp
(map! :map emacs-lisp-mode-map
      ;; Rearrange Sexps
      :n "s-k"   (λ! (sp-transpose-sexp)
                     (evil-previous-line))
      :n "s-j"   (λ! (sp-push-hybrid-sexp)
                     (evil-next-line))
      :n "s-r" #'eval-buffer
      ;; Slurp and barf
      :n "g]"   #'sp-slurp-hybrid-sexp
      :n "g["   #'sp-forward-barf-sexp)
#+END_SRC
*** Other Bindings

Other bindings and overrides that dont fit anywhere else.

**** Copy and Paste from the minibuffer

Since the minibuffer has no evil mode, i've got these bindings to help out:
- ~M-c~: Copy the minibuffer line
- ~M-v~: Paste from clippboard to minibuffer (Same as ~C-r 0~)
         This also removes trailng newlines

#+BEGIN_SRC elisp
(defun evil-get-register-string (REGISTER)
  "Get evil-register pure text content
Registers can be selected with ?letter
E.g.: ?* -> Clipboard Contents"
  (evil-vector-to-string (evil-get-register REGISTER)))

(defun paste-evil-register-clipboard-pruned ()
  "Paste the current clipboard pruned from newlines"
  (interactive)
  (insert (s-trim (shell-command-to-string "pbpaste")))
  (doom/forward-to-last-non-comment-or-eol))

(defun copy-minibuffer-line ()
  "Copies the minibuffer content to the clipboard"
  (interactive)
  (save-excursion
    (doom/forward-to-last-non-comment-or-eol)
    (set-mark-command nil)
    (doom/backward-to-bol-or-indent)
    (kill-ring-save (mark) (point))))

(defun setup-minibuffer ()
  "Set up keybindings for the minibuffer"
  (local-set-key (kbd "s-v") 'paste-evil-register-clipboard-pruned)
  (local-set-key (kbd "s-c") 'copy-minibuffer-line))

(add-hook 'minibuffer-setup-hook 'setup-minibuffer)
#+END_SRC
